// 소스파일
// 주석(Comment) : 프로그램에 영향을 끼치지 않는 부분 (컴파일러가 무시하는 문장)
//

/*
Ctrl+D : 한줄 복제하기
Shift+Delete : 한줄 삭제하기
Shift+화살표 : 블럭 잡기
Alt+Shift+화살표 : 세로로 블럭 잡기
Ctrl+spcae : 자동완성기능(인텔리센스)창 띄우기
Alt+화살표위아래 : 현재 줄을 위아래로 옮기기 ㅠ
프로그램 디버그: <F5 키 또는 [디버그] > [디버깅 시작] 메뉴
Ctrl+B+B : 프로젝트 빌드
Ctrl+B+R : 프로젝트 리빌드
Ctrl+화살표 위아래 : 보이는 영역 올리고 내리기
Ctrl+화살표 좌우 : 단어 단위로 움직이기
Ctrl+K+C : 블럭 영역 전부 주석처리
Ctrl+K+U : 블럭 영역 전부 주석해제 처리
*/

/*
컴파일러 : 번역기(사람이 써 놓은 코드를 기계가 알아듣게 번역해줌)
 -> 목적코드 생성
  -> 링커가 연결해서 실행파일 생성
빌드 : 실행파일 생성하기
리빌드 : 전체 다시 빌드하기(정리+빌드)
*/

/*
변수(Variable)
 - 변하는 숫자
 - 컴퓨터에 값을 기억 시키기 위해 만들고 사용
*/

/*
연산자(Operator)
 - 계산을 하기 위한 기호
 - 대입 연산자
   =
   = 오른쪽에 있는 값을 왼쪽에 넣어라
   a = b; // b에 있는 값을 a에 넣어라
 - 산술 연산자
	사칙연산
	+(더하기) -(빼기) *(곱하기) /(나누기) %(나머지 연산)
	 a = 5%3;
	 a에는 2가 들어간다.( 5를 3으로 나누었을 때 나머지가 2 )
 - 복합 대입연산자
	줄여쓰기용
	a += b;		// 아래와 같은 코드
	a = a + b;
 - 증감 연산자
	a++;	// a에다가 1을 더해라.
	a--;	// a에다가 1을 빼라.
*/

/*
이진수(Binary)
 - 컴퓨터는 0과 1만 알수 있기 때문에 기본적으로 이진수를 사용

 int number = 10;	// 사람이 알아보기 위해 10진수로 값을 대입
					// 실제 메모리에는 0000 0000 0000 0000 0000 0000 0000 1010

 ex) 13 = 2^3 * 1 + 2^2 * 1 + 2^1 * 0 + 2^0 * 1 = 1101
*/

/*
데이터 타입
int : 정수형. 일반적으로 32bit. 범위는 (대략 -21억~+21억)
float : 실수형. 32bit. 태생적으로 오차가 있는 타입. 대략 총7자리부터 오차 발생
double : 실수형. 64bit.
bool : 불리언. true/false만 저장.
char : 캐릭터. 글자하나를 저장하는 데이터 타입. 8bit 정수형
	char alpha = 'a';	// 글자 하나만 저장
	char alpha2 = 64;
std::string : 스트링. 문자열을 쉽게 다룰 수 있는 자료형.
	문자열 : 글자 여러개가 연결된것
	std::string str = "Hello World!";
	char* str;
	char str[32];
*/

/*
상수(Constant)
 - 변하지 않는 수
 - 코드의 안정성과 가독성을 높여준다.
	(매직넘버 회피에 좋다)
	(매크로로와는 달리 타입체크가 가능하다)
*/

/*
비교연산자
 - 비교를 하는 연산자. 참이냐 거짓이냐가 결과로 나온다.
 - >, <, >=, <=, ==

 int a = 10;
 int b = 20;
 bool result = a > b;		// 결과는 거짓이니까 result = false;

 int a = 100;
 int b = 20;
 bool result = a > b;		// 결과는 참이니까 result = true;

 int a = 50;
 int b = 50;
 bool result = a == b;	// 결과는 참이니까 result = true;

 // ‘실수형 자료형은 비교 연산자를 사용하면 안 된다’ 가 맞을까요?
 // 정확하게 이야기하면
	"값이 같은지를 비교하는 ==, <=, >=를 조심해서 사용해야 한다." 입니다.
*/

/*
제어문
 - 프로그램의 흐름을 제어하는 문(Statement)
  - 조건문 : 조건에 따라 프로그램의 흐름을 변경하는 문
	- if, else if, else
	- switch
	- 삼항연산자
  - 반복문 : 일정 조건에 따라 코드를 반복하는 문
*/

/*
논리 연산자
 - bool값을 받아 bool로 된 결과를 낸다.
&&	(And)	&&의 양쪽이 둘 다 true면 true. 그 외는 false
||	(Or)	||의 양쪽에 하나라도 true가 있으면 true, 아니면 false
!	(Not)	! 뒤의 bool이 true면 false, false면 true.
*/

/*
비트 연산자
&	(And)	두 비트가 모두 1이면 1, 아니면 0
	특정 비트가 세팅이 되어 있는지 확인하는데 사용(플래그 검사)
	int a = 10;			// 0b1010
	int b = 9;			// 0b1001
	int c = a & b;		// 0b1000
|	(Or)	두 비트가 하나라도 1이면 1, 둘 다 0이면 0
	특정 비트에 플래그를 세팅하고 싶을 때 사용(플래그 설정)
	int a = 10;			// 0b1010
	int b = 9;			// 0b1001
	int c = a | b;		// 0b1011
^	(XOR)	두 비트가 서로 다르면 1, 같으면 0
	특정 비트를 토글하고 싶을 때 사용
	int a = 10;			// 0b1010
	int b = 9;			// 0b1001
	int c = a ^ b;		// 0b0011
~	(Not)	비트값을 반전 시킨다(0->1, 1->0)
	int a = 10;			// 0b1010
	a = ~a;				// 0b0101
<<	(Left Shift)	비트들을 왼쪽으로 이동
	한번 움직일 때마다 수가 두배가 된다.
	int a = 7;			// 0b0111
	a = a << 1;			// 0b1110
>>	(Right Shift)	비트들을 오른쪽으로 이동
	한번 움직일 때마다 수가 절반이 된다.
	int a = 7;			// 0b0111
	a = a >> 1;			// 0b0011
*/

/*
반복문
 - 제어문 중의 하나
 - 특정 코드 블록을 조건에 따라 여러번 반복해서 실행할 수 있게 해주는 문
 for		반복 회수가 명확할 때 좋음
 while		반복 회수가 명확하지 않고 조건에 따라 반복할 때 사용
 do-while	최소 한번은 무조건 실행해야 할 때 사용.(while과 거의 같음)
*/

/*
* continue
*	- 반복문 안에서 사용
*	- continue를 만나면 그 이후의 코드는 스킵하고 다음 반복을 진행
* break
*	- 반복문이나 switch문에서 반복문을 벗어나거나 case를 종료시킨다.
*/

/*
* 랜덤
*  - 무작위로 숫자를 선택하는 법
*  - C 스타일
*		- rand();			함수 활용
*		- srand(time(0));	시드값 설정
*  - C++ 스타일
*		- #include <random>
*		- c스타일보다 많은 기능을 제공한다.
*/

/*
* 함수(Function)
*  - 특정한 기능을 수행하는 코드블럭
*  - 선언을 하고 사용해야 한다.
*		->함수의 리턴타입, 함수의 이름, 함수의 파라메터를 설정해줘야 한다.
		함수의 리턴타입 : 함수가 끝났을 때 돌려 받을 값의 종류
		함수의 이름 : 함수를 호출(사용)하고 싶을 때 부르는 이름
		함수의 파라메터 : 함수의 입력값. 0개 이상 들어갈 수 있다.
	- 선언을 한 후에는 구현을 정의해야한다.(함수의 실제 동작을 작성)
*/

/*
* 재귀 호출(Recurcive Call)
*  - 함수 안에서 자기자신을 다시 호출하는 함수
*/

/*
* 템플릿(Template) 함수
*  - 데이터 타입에 관계 없이 동일한 로직을 여러 자료형에 대해 사용할 수 있게 해주는 C++의 기능
*  - 컴파일 타임에 실제 사용하는 곳이 있으면 해당 타입으로 코드를 생성한다.
*		-> 해더에 선언과 구현이 함께 있어야 한다.
*/

/*
* 인라인(inline) 함수
*	- 함수 호출문을 해당 함수의 실제 코드로 대체하는 함수
*/

/*
* 스코프
*  - 변수, 함수, 객체등이 유효하게 사용될 수 있는 범위
*  - 일반적으로 선언된 중괄호 안쪽에서만 유효
*  - 지역 변수 : 특정 함수 내에서 선언된 변수
*  - 전역 변수 : 프로그램 전체에서 사용할 수 있는 변수
*/

/*
* 배열(Array)
* - 같은 데이터타입을 가진 요소들이 연속적으로 저장되어 있는 데이터 구조
*   int Array[5];	// int 5개짜리 배열
*   Array[2] = 10;	// 3번째 요소에 접근해서 10을 대입한다.
*
* - 장점 : 빠르게 각 요소에 접근이 가능하다.
* - 단점 : 크기가 고정이다. 중간에 데이터 삽입/삭제가 어렵다.
*
* 이차원 배열
* - 배열을 이차원으로 표현한 것(축이 2개)
* - int Array[4][3] = { {1,2,3}, {4,5,6}, {7,8,9}, {0,1,2}};
*	int 3개짜리 배열이 4줄 들어있다.
*	사실 int Array[12]랑 메모리 구조가 같다.
*/

/*
* 캐스팅(Casting)
*  - 하나의 데이터 타입을 다른 데이터 타입으로 변경하는 행위
*
	int a = 10;
	float b = 15.5f;

	// C 캐스팅
	a = (int)b;	// b를 int형으로 캐스팅해서 a에 대입한다. (C스타일, 명시적 캐스팅)
	a = b;		// b를 a에 대입한다. 그런데 a와 b는 타입이 다르니까 b를 a로 암시적으로 캐스팅해서 대입한다.(C스타일, 암시적 캐스팅)
	b = a;		// 암시적 캐스팅은 대체로 표현이 작은쪽에서 큰쪽으로는 문제없는 경우가 많다.

	// C++ 캐스팅
	// static_cast : C스타일 캐스팅을 안전하게 만든 것. 컴파일 타임에 결정됨
	// dynamic_cast : 다음에(클래스 이후에)
	// const_cast : const 속성을 제거하거나 추가하는데 사용. 사용하지 않는 것이 권장.
	// reinterpret_cast : C스타일 캐스팅에서 위험한 부분. 원래 타입의 구조를 무시하고 새 타입으로 해석하게 한다.
	a = static_cast<int>(b);	// b를 int형으로 캐스팅해서 a에 대입한다. (C++스타일, 명시적 캐스팅)
*/

/*
* 피셔-예이츠 알고리즘
*	- 배열의 내용을 랜덤하게 섞는 셔플 알고리즘
*	- 동일한 확률로 섞이도록 증명 완료된 알고리즘
*
*	- 알고리즘 순서
*		1. 배열의 마지막 요소에서 첫 요소까지 순회.
*		2. 현재 요소의 인덱스(i)와 , 0~i 중 임의의 인덱스(j)를 선택한다.
*		3. i번째 요소와 j번째 요소를 서로 교환
*		4. i가 0이 될 때까지 반복
*/

/*
* 참조(Reference)
*  - 변수의 별명
*		int Number = 10;
*		int& Ref = Number;	// Number의 참조를 Ref라고 결정
*		Ref = 20;			// Number가 20으로 수정된다.
*  - 참조를 변경할 경우 원본 변수도 함께 수정된다. -> 함수 파라메터로 사용하면 편리하다.
*  - 참조는 항상 어떤 변수와 연결되어 있어야 한다.
*  - 함수 파라메터에 참조를 사용할 때
*		- 파라메터 값을 수정하는 출력용 파라메터일 경우 Out이라는 접두사를 붙이는 것이 관례이다.
*		- 파라메터 값을 읽기만 하는 경우에는 const를 붙여줘서 실수로라도 고칠 수 없게 하는 것이 좋다.
*/

/*
* 포인터
* - 메모리 주소를 저장하는 데이터 타입
* - 각 데이터타입에 *만 붙이면 포인터 타입
*	- ex) int* 인티저 포인터, float* 플로트 포인터, char* 캐릭터 포인터
* - 포인터 연산자
*	- 주소 연산자(&) : 변수의 주소를 가져온다.
*		int i = 10;
*		int* p = &i;	// i의 주소를 int* p에 대입해라.
*	- 간접참조 연산자(*) : 포인터 변수가 가리키는 주소에 저장되어 있는 실제 값
*		int i = 20;
*		int* p = &i;
*		(*p) = 30;		// i = 30;과 같다.
*	- 산술 연산자 ( +, -, ++, -- )
*		int i = 30;
*		int* p = &i;
*		p = p + 1;		// 예시로 p가 원래 0x0004라고 가정했을 때 p + 1을 한 값은 4(int의 크기)가 증가해서 0x0008
*		double d = 10.5;
*		double* pD = &d;
*		pD += 1;		// pD가 원래 0x0000이라고 가정했을 때 pD += 1은 8(double의 크기)이 증가해서 0x0008
*  - 배열과 포인터는 기본적으로 같다.(배열의 이름은 배열의 첫번째 요소의 주소이다.)
*/

/*
* C++의 메모리 영역(단순화 된 버전)
*  - 코드 영역 : 실행코드가 저장되는 공간
*  - 데이터 영역
*		프로그램이 시작할 때부터 끝날 때까지 유지되는 변수가 저장되는 공간
*  - 힙 영역
*		램 그 자체
*		프로그램 실행 중에 프로그램이 필요에 따라 직접 메모리를 할당 받고 사용하는 공간
*		힙은 운영체제가 관리하기 때문에 힙을 할당받는 행위는 느리다.
*		메모리를 할당 받았으면 반드시 해제를 해줘야 한다.(해제를 하지 않으면 메모리 릭(메모리 누수) 발생)
*  - 스택 영역
*		함수가 호출될 때마다 필요한 변수(지역 변수)가 저장되는 공간
*		함수가 끝나면 자동으로 정리
*/

/*
* 정적(static)	: 프로그램 실행전에 이미 결정 나 있는 것들.
* 동적(dynamic)	: 프로그램 실행 중에 결정이 되는 것들.
*/

/*
* 동적 할당(Dynamic Allocation)
*  - 프로그램 실행 중(Runtime)에 메모리를 사용하기 위해 확보하는 행위
*  - 운영체제(OS)에게 요청함 -> 그래서 늦다.
*  - C 스타일
*		할당 : malloc
*		해제 : free
*		단순 메모리 블럭만 받는 형식(초기화가 없음. 타입 안정성 없음. 생성자/소멸자 실행안됨)
*  - C++ 스타일
*		할당 : new
*		해제 : 일반 변수는 delete, 배열은 delete[]
*		int* Data = new int(5);		// int 하나를 할당 받는데 주소가 가리키는 값은 5를 설정해라
*		delete Data;
*		Data = nullptr;
*		int* Array = new int[10];	// int 10개짜리 배열을 만들어라
*		delete[] Array;				// 배열은 반드시 이렇게 해제해야 한다.
*		//delete Array; // 절대 이렇게 하면 안된다. 이렇게 하면 Array[0]부분만 할당 해제가 된다.
*		Array = nullptr;
*		특정 객체(Object)를 생성하는 방식.(초기화가 있다. 타입 안정성이 있다. 생성자와 소멸자가 실행된다.)
*  - 메모리 할당과 성능 문제
*		메모리 할당은 오래 걸린다.(컴퓨터 입장에서 느리다. 운영체제의 메모리관리나 적절한 사이즈를 찾는데 시간이 걸림)
*		메모리 단편화 문제(메모리 할당 해제를 반복하다가 전체 빈공간은 충분하지만 연속된 빈공간이 부족해지는 현상)
*  - 메모리 릭(메모리 누수)
*		할당한 메모리를 반환하지 않아 해당 영역을 사용하지 못하게 되는 현상
*/

/*
* 문자열
*  - 글자 여러개를 모아 문장을 만들어 놓은 것.
*  - C언어에서는 문자열을 표현하기 위해 char*를 사용.(=> char[]을 쓰기도 한다)
*  - 항상 마지막 문자열은 널 문자('\0')로 끝난다.
*  - char*에는 아스키 코드가 기록된다.
*/

/*
* 파싱(Parsing)
* - 문자열을 분석해서 의미있는 정보로 변환하는 과정
*/

/*
* 구조체(Struct)
*	- 여러 종류의 데이터타입을 하나로 묶을 때 사용.
*	- 프로그램 코드의 가독성과 유지 보수성을 향상시켜 준다.
*	struct Enemy
*   {
*		std::string Name;
*		float Health;
*		float AttackPower;
*		int DropGold;
*   }
*	Enemy goblin;		// 적 하나에 대한 정보 만들기
*	Enemy goblins[3];	// 적 3마리에 대한 정보 만들기
*
*	- 구조체 동적 할당하는 법
*	Enemy* pGoblin = new Enemy();	// 새 적을 동적할당 받음
*	delete pGoblin;					// 동적할당 받은 것을 해제
*	pGoblin = nullptr;
*
*	- 구조체 데이터 접근법
*		- 일반적인 경우 점(.) 연산자 사용
*			goblin.Name = "고블린";
*			goblin.Health = 20;
*		- 포인터 변수인 경우 화살표(->) 연산자 사용
*			pGoblin->AttackPower = 5.0f;
*			pGoblin->DropGold = 100;
*	- 구조체의 생성자
*		- 객체가 만들어질 때 자동으로 호출되는 특별한 함수
*		- 객체
*			int i = 10;		// 인티저 객체 하나가 만들어짐
*			int array[3];	// 인티저 객체 3개가 만들어짐
*			Enemy* pEnemy = new Enemy();	// Enemy 객체 하나가 만들어짐
*		- 맴버 변수 초기화에 사용(값을 계산하거나 변경해서 넣을 때 좋음)
*		- 일반 함수와 다른 특징
*			1. 이름이 구조체 이름과 같다.
*			2. 리턴 타입이 없다.
*			3. 객체가 만들어질 때 자동으로 호출됨
*			4. 생성자가 여러개 있을 수도 있다.
*			5. 없으면 기본 생성자가 자동으로 만들어진다(무조건 하나는 있다)
*	- 구조체의 명령어 오버로딩(덮어쓰기)
*		- 각종 연산자
*/


//객체지향
//- 객체(Object) : 게임 상에 존재하는 모든 것.
//- 객체지향 : 객체를 중심으로 프로그램을 설계하는 것.
//- 클래스 : 객체를 만들기 위한 설계도. 객체가 가져야할 상태(데이터)와 동작(기능)을 하나로 묶어 놓은 것
//- 객체지향의 4대 특성
//	-추상화
//		-불필요한 세부사항을 숨기고, 핵심적인 부분만 보여주는 것
//		-코드의 복잡성을 낮출 수 있다(=이해하기가 쉬워진다)
//	-캡슐화
//		-접근제한자를 통한 데이터의 접근 제어
//		-몰라도 되는 것은 안보여야 한다.(데이터를 보호하고 코드의 안정성을 높이고 결합도도 떨어트린다)
//	-상속
//		-부모 클래스(기본클래스)의 데이터와 기능을 물려받은 자식 클래스(파생클래스)를 만드는 것
//		-코드의 재사용성을 높이고 계층 구조를 형성한다.
//	-다형성
//		-동일한 인터페이스를 통해 다양한 처리를 하는 것
//		-가상 함수의 오버라이드를 통한 다형성 구현
//
//
//	클래스
//	-객체를 만들기 위한 설계도
//	-객체가 가지게 될 상태와 동작을 하나로 묶어 놓은 것
//	-인스턴스 : 클래스를 기반으로 실제 메모리에 만들어진 실체(new 하는 것)
//	-구성요소
//		- 생성자 : 구조체와 같음. 객체를생성했을 때 자동 호출되는 특별한 함수
//		- 소멸자 : 구주체나 객체가 해제될 때 자동으로 호출되는 특별한 함수
//			-객체가 사용하던 자원을 깨긋이 정리되는 역할
//			-클래스 내부에서 동적할당한 메모리를 해제하는 데 주로 사용(메모리 릭 방지)
//		-맴버 변수 : 객체의 상태나 데이터를 저장하는 변수. (속성, 필드라고도 함)
//		-맴버 함수 : 객체가 할 수 있는 동작이나 기능을 정의한 함수.(매서드라고 함)

//접근제한자(Access Modifier)
//	- 이 객체의 내부를 누구까지 볼 수 있을 것인가를 설정
//	- public, protected, private
//	- public : 누구든지 접근 가능하다. //뒤에 전부다 퍼블릭으로 자기 앞에 접근 제한자에 따라 권한 달라짐
//	- private : 나만 접근 가능하다 //있는지 없는지 조차 모름
//	- protected: 나와 나를 상속받은 대상만 접근 가능하다. 
//	- 구조체의 접근제한자 : 설정안하면 기본 public
//	- 클래스의 접근제한자 : 설정안하면 기본 private
//
//
//상속
//-부모 클래스의 맴버를 물려 받는 행위
//-특징
//	-코드 재사용성이 증가한다
//	-계층구조로 객체들의 관계를 명확히 할 수 있다.
//	-부모 클래스의 포인터나 참조를 통해 자식 클래스를 다룰 수 있다.


#define _CRT_SECURE_NO_WARNINGS
#define _CRTDBG_MAP_ALLOC
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#include <crtdbg.h>

#include <iostream>	// 입출력 관련(cout)
#include <stdio.h>
#include <time.h>
#include <cstdio>	// stdio.h에 네임스페이스 추가한 래퍼
#include <random>
#include "header.h"
#include "TestMath.h"
#include "Practice_0905.h"
#include "Day0908.h"
#include "Day0909.h"
#include "Day0910.h"
#include "Day0911.h"
#include "Day0912.h"
#include "Day0915.h"
#include "Day0916.h"
#include "Position.h"


int global = 10;
//using namespace std;

int main() // 엔트리 포인트(코드가 시작되는 곳)
{
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	srand(time(0));

	printf("\n\n\n\n\n\n\n\n\n");

	Day0916 day0916;
	//day0916.ClassInstance();
	//day0916.TestAnimal();
	day0916.TestTiger();

	//Day0915_WeekPracticeBlackjackTest();
	//Day0915_WeekPracticeBlackjack();

	//Day0915_WeekPractice();
	//Day0915_WeekPracticeTest();



	/*Position* pPos = new Position(2, 3);
	delete pPos;
	pPos = nullptr;*/

	//Position pos2;
	Position pos2 = Position();

	//Day0912_Struct();
	//Day0912_OperatorOverloading();

	//Day0911();

	//Day0910_String();

	//int* p = nullptr;
	//Day0909();
	//Day0909_ArrayAndPointer();
	//Day0909_DynamicAllocation();
	//Day0909_Example();
	//Day0908_Practice1();
	//Day0908_Practice2();
	//Day0908_Practice3();
	//MazeEscapeRun();

	//Day0908();
	//Day0908_Ref();

	return 0;
}

void Test()
{
	global = 100;
}
// 프로그램 실행: <Ctrl+F5> 또는 [디버그] > [디버깅하지 않고 시작] 메뉴


// 시작을 위한 팁: 
//   1. [솔루션 탐색기] 창을 사용하여 파일을 추가/관리합니다.
//   2. [팀 탐색기] 창을 사용하여 소스 제어에 연결합니다.
//   3. [출력] 창을 사용하여 빌드 출력 및 기타 메시지를 확인합니다.
//   4. [오류 목록] 창을 사용하여 오류를 봅니다.
//   5. [프로젝트] > [새 항목 추가]로 이동하여 새 코드 파일을 만들거나, [프로젝트] > [기존 항목 추가]로 이동하여 기존 코드 파일을 프로젝트에 추가합니다.
//   6. 나중에 이 프로젝트를 다시 열려면 [파일] > [열기] > [프로젝트]로 이동하고 .sln 파일을 선택합니다.
