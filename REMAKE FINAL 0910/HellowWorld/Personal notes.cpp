// 변수 Variable
//"변하는 값"을 담는 이름 있는 메모리 공간
//
//상수 Constant / const
//바뀌지 않는 값.const를 붙이면 수정 불가.
//const int N = 5; // N은 수정 불가(compile-time 상수로 쓰기 좋음)
//
//리터럴 Literal
//코드에 직접 적은 값
//
//기본 자료형
//
//- bool: 논리형, true / false (1바이트)
//- char : 문자 1개(1바이트)
//- int : 정수(보통 4바이트, -2, 147, 483, 648 ~2, 147, 483, 647)
//- long long : 큰 정수(8바이트)
//- float : 단정밀도 실수(4바이트, 소수 약 6~7자리 정확)
//- double : 배정밀도 실수(8바이트, 소수 약 15~16자리 정확)
//- unsigned : 부호 없음(음수X).예) unsigned int
//
//이스케이프 시퀀스
//"\n"(줄바꿈), "\t"(탭), "\\", "\"\"", "\r"(캐리지 리턴; 주로 리눅스 / 터미널)
//
//enum (열거형, enumeration)
//    - 의미 있는 정수 상수의 묶음.가독성↑, 매직넘버 제거.
//    - 예) enum Item { Gun = 1 << 0, Bomb = 1 << 1, ... };
//
//표현식 / 문 Expression / Statement
//- 식(Expression) : 값이 되는 계산식.예) a + b, i < 10
//    - 문(Statement) : 실행 단위.예) a = 3; if (...) { ... }
//
//연산자 Operator
//1) 대입: a = b; // 오른쪽 값을 왼쪽에 복사(오른쪽은 변하지 않음)
//2) 산술: +-*/ %
//-정수 나눗셈 : 7 / 2 == 3 (소수 버림)
//- % : 나머지(modulo) → 5 % 3 == 2
//3) 복합 대입 : a += b;  // a = a + b; ( -=, *=, /=, %= )
//4) 증감: a++; ++a; a--; --a;
//-a++(후위, post) : "사용 후" + 1
//- ++a(전위, pre) : "+1 후" 사용
//- 잘못된 표기 : a++ = (X)
//5) 비교: == , != , <, >,
//
//#define _CRT_SECURE_NO_WARNINGS
//#include <cstdio>    // printf, scanf
//#include <cstdlib>   // srand, rand
//#include <ctime>     // time
//#include <random>    // C++ 난수(random) 엔진/분포
//
//
//- for문(반복문, loop)
//- for (초기식; 조건식; 증감식) { 본문 }
//- 실행 순서 : 초기식 →[조건 검사→본문→증감] 반복 → 조건 거짓이면 종료
//- 예) for (int i = 0; i < 5; ++i) { /* 5회 반복: i=0..4 */ }
//
//비트 연산(bitwise)
//- OR(| ) : 켜기 / 추가, AND(&) : 검사, AND NOT(&~) : 끄기 / 삭제, SHIFT(<< , >> ) : 자리 이동
//- 예) inv |= Gun;    // Gun 추가
//-if (inv & Gun) // Gun 보유 여부 검사
//- inv &= ~Gun;   // Gun 제거
//
//
//[랜덤(Random) 정리:C 스타일 vs C++ 스타일]
//
//1) C 스타일(rand / srand) 요약
//- srand(time(0));           // 실행할 때마다 다른 "시드(seed)" 설정
//-srand(0);                 // 고정 시드(테스트 재현용)
//-int r = rand();           // 0 ~ RAND_MAX 정수
//-int x0_5 = rand() % 6;    // 0~5
//-int x1_6 = rand() % 6 + 1;// 1~6 (주사위)
//
//※ 주의 : (rand() % n)은 "모듈러 편향(modulo bias)"가 있을 수 있음.
//학습·간단 실습은 OK, 정밀 난수는 C++ <random> 권장.
//
//2) C++ 스타일(<random>) 요약  ← 권장(예측 어려움)
//- std::random_device rd;          // 시드 공급원(일부 구현은 의사난수)
//-std::mt19937 gen(rd());         // 메르센 트위스터 엔진(빠르고 품질 좋음)
//-std::uniform_int + _distribution<int> uni(a, b); // [a, b] 균등분포,uniform)
//-int v = uni(gen);               // a~b 정수 1개
//-std::normal_distribution<double> norm(mu, sigma); // 정규분포,(normal/Gaussian)
//-double z = norm(gen);
//
//-1~6:  rand() % 6 + 1
//- 0~n - 1 : rand() % n
//- 정규분포 출력 시 소수점 형식 지정 필요(printf("%.2f", value);)
//
//rand() % 6 + 1 괄호는 현재 우선순위상 필수 아님이 맞으나, 가독성 위해 괄호로 감싸는 습관 추천.
//1e6 반복 정도는 int로 충분.더 큰 카운트는 long long 사용 고려.
//
//
//
//[비교 / 조건 / 논리 기본 요약]
//- 비교연산자(comparison operators) : > , < , >= , <= , == (같다), != (다르다)
//    -결과 타입 : bool → true / false
//    - = (대입, assignment) 와 == (비교, equality)를 절대 혼동하지 말 것!
//
//
//    [if / else if / else]  — 조건(condition)이 true일 때 블록 실행
//    문법 :
//if (조건) { … }
//else if (다른 조건) { … }
//else { … }
//
//주의1) if (cond); ← 세미콜론 실수 금지!(빈 문장을 실행해 버림)
//주의2) 범위 큰 조건 → 작은 조건 순서로 배치하면 가독성↑, 버그↓
//
//
//[switch] — 정수 / 열거형을 값별로 분기.각 case 끝에 break 필수.
//
//
//[삼항 연산자(ternary)]  cond ? A : B
//- cond가 true면 A, false면 B의 값이 선택됨.
//
//[논리 연산자]
//- && (AND), || (OR), !(NOT)
//-단락 평가(short - circuit) : 왼쪽만으로 결과가 확정되면 오른쪽은 평가 안 함.
//
//[개념 보충] 비교 / 논리 / 부정 연산자
//- 같지 않다 : a != b(주의 : 공백 섞은 a != b 는 문법 오류)
//- AND : &&, OR : || , NOT : !
//- 단락 평가(short - circuit) : 왼쪽으로 결과가 결정되면 오른쪽 미평가.
//
//예시(주석) :
//     int a = 10, b = 20;
//     if (a != b) { /* 다름 * / }
//     if ( (a > 5) && (a < 15) ) { /* 범위 내 * / }
//
//
//    [자주 하는 실수 체크리스트]
//- '=' vs '==': 대입과 비교 혼동 금지.
//- if (cond);  ← 세미콜론 실수 금지.
//- float == 비교: epsilon으로 근사 비교.
//- switch : break 빠뜨리지 않기(의도적 fall - through엔 주석 남기기).
//- 변수 스코프 : 사용 직전에 선언(가독성↑).
//- 논리식은 '읽기 쉬운 순서'로 작성(짧은 회로 평가 활용).
//
//
//- 비교(comparison) : 두 값을 대조하여 관계를 판별하는 행위.
//- 조건(condition) : 참 / 거짓을 결정하는 논리식.
//
//[디버그 팁]
//- F9 : 브레이크포인트 설정 / 해제
//- F10 / F11 : 한 줄씩 / 함수 안으로
//- 변수 감시(Watch), 즉시(Immediate) 창으로 식 평가
//- 포맷 출력 : % d(int), % u(unsigned), % f(float), % .2f(소수 둘째 자리), % c(char), % s(C - string)
//
//[디버그 / 포맷 팁]
//- % d(int), % u(unsigned), % f(float), % .2f(소수 둘째), % c(char), % s(C - string)
//- if 뒤에 세미콜론 금지 : if (cond);  ← 버그!
//- 비교 연산자 : == (같다), != (다르다), <, >, <= , >=
//-대입 연산자 : = (절대 혼동 금지)
//
//[용어]
//- modulo : 나머지
//- short - circuit : && /||에서 결과 확정 시 나머지 미평가
//- LSB : 최하위 비트(Least Significant Bit)
//
//
//[제어문(Control Statements) 개요]
//- 프로그램의 흐름을 제어하는 문(statement).
//- 조건문 : if / else if / else, switch, (조건) ? A : B  ← 삼항연산자
//- 반복문 : for / while / do - while
//
//[논리 연산자[Logical)]
//- 피연산자:bool → 결과 : bool
//- && (AND) : 양쪽이 모두 true → true, 그 외 false
//- || (OR) : 둘 중 하나라도 true → true, 둘 다 false → false
//- !(NOT) : 피연산자가 true → false, false → true (참 / 거짓 반전)
//- 단락 평가(short - circuit) : && /||는 왼쪽만으로 결과가 확정되면 오른쪽은 평가하지 않음.
//EN : && and || short - circuit; !negates a boolean.
//주의: 'ture' 오타 주의 → 'true'
//
//[비트 연산자(Bitwise)]  ※ 정수형에 대한 비트 단위 연산
//- &(AND) : 두 비트가 모두 1 → 1, 아니면 0  (플래그 검사에 유용)
//- | (OR) : 두 비트 중 하나라도 1 → 1       (플래그 세팅에 유용)
//- ^ (XOR) : 두 비트가 다르면 1, 같으면 0    (토글 toggle)
//- ~(NOT) : 비트 반전(0↔1)                   (주의 : 2의 보수 표현으로 부호 / 상위비트까지 반전)
//- << (Left) : 왼쪽 시프트(2배씩 커짐처럼 보임)  (오버플로 / 손실 주의, 부호형 금지 권장)
//- >> (Right) : 오른쪽 시프트(2로 나눈 효과처럼 보임)
//* 부호 있는 정수의 >> 는 구현마다 산술 / 논리 시프트 차이 주의(대부분 산술 : 부호비트 유지).
//* 음수 / 너무 큰 시프트 폭은 정의되지 않은 동작(UB).
//
//
//[비트 예시 1:AND로 특정 비트 검사]
//int a = 10; // 0b1010
//int b = 9;  // 0b1001
//int c = (a & b); // 0b1000
//
//[비트 예시 2:OR로 특정 비트 켜기]
//int a2 = 10; // 0b1010
//int b2 = 9;  // 0b1001
//int c2 = (a2 | b2); // 0b1011
//
//[비트 예시 3:XOR로 토글]
//int a3 = 10; // 0b1010
//int b3 = 9;  // 0b1001
//int c3 = (a3 ^ b3); // 0b0011
//
//[비트 예시 4:NOT로 반전(주의)]
//int a4 = 10;     // 0b...00001010 (플랫폼의 int 폭만큼)
//int n4 = ~a4;    // 0b...11110101 (부호/상위비트까지 뒤집힘 → 마스크를 함께 쓰는 습관)
// 예: 하위 4비트만 반전하려면: n4 = (~a4) & 0b1111;
//
//[시프트 예시]
//unsigned int s = 7;   // 0b0111
//s = s << 1;           // 0b1110  (왼쪽으로 1칸: 대략 *2)
//s = s >> 1;           // 0b0111  (오른쪽으로 1칸: 대략 /2)
//
//[플래그(Flag) 패턴 예시] ← 방향키 입력 상태를 4비트로 관리
//- 0b0001 = 왼쪽(Left), 0b0010 = 오른쪽(Right), 0b0100 = 위(Up), 0b1000 = 아래(Down)
//- C++14 이상: 0b 접두 이진 리터럴 사용 가능(MSVC 지원)
//
//int flag = 0b1010; // 현재: Right(0010) + Down(1000)이 켜진 상태
//
// 1) 특정 비트가 켜져 있는지 검사(AND 후 0이 아닌지)
//if ((flag & 0b0010) != 0) {
//     오른쪽 키가 눌려있다.
//}
//else {
//     오른쪽 키가 눌려있지 않다.
//}
//
// 2) 비트를 켜기(OR)
//flag = flag | 0b0001; // Left ON → flag = 0b1011
//
// 3) 비트를 토글(XOR)
//int result = flag ^ 0b0001;   // Left 토글
//result = result ^ 0b0001;     // 다시 토글 → 원복
//
// 4) 비트를 끄기(AND with NOT)
//flag = 0b1010;
//flag = flag & (~0b0010); // Right OFF → 0b1000
//
// 5) 전체 비트 반전 시 하위 N비트만 유지하고 싶을 때는 마스크 사용
//int test = 0b0001;
//int mask4 = 0b1111;
//int inv4 = (~test) & mask4;  // 하위 4비트만 반전 → 0b1110
//
//[enum : 상수 집합에 이름 부여(가독성↑, 매직넘버 제거)]
//- C 스타일 : enum Key { Up = 1 << 0, Down = 1 << 1, Left = 1 << 2, Right = 1 << 3 };
//-사용: if ((flag & Up) != 0) { … }
//주의: enum 항목명 / 변수명 대소문자 일치, 콤마 위치 / 초기화 문법 정확히.
//
//[반복문(Loops)]
//- for : 반복 횟수가 명확할 때(인덱스 기반)
//- while : 조건이 참인 동안(반복 횟수 불명확, 선조건 검사)
//- do - while : 최소 1회 실행 보장(후조건 검사)
//- continue : 이번 반복의 나머지 문장 건너뛰고 다음 반복으로
//- break : 반복문 / switch 탈출
//
//
//[랜덤(Random]
//    - C 스타일 : srand(시드); rand();  // 단순 실습용, 모듈러 편향 가능
//예) srand(time(0)); int dice = rand() % 6 + 1; // 1~6
//-C++ 스타일(<random>) : std::mt19937 엔진 + 분포
//예) std::uniform_int_distribution<int> d(1, 6); int v = d(gen);
//EN: Prefer <random> for quality / reproducibility; avoid modulo bias.
//
//[에디터 / IDE 작업 팁(Visual Studio 기준)]
//- alt + shift + 화살표 : 세로 블록 선택(멀티컬럼)
//- ctrl + d : 한 줄 복제
//- ctrl + space : 자동완성(인텔리센스)
//- shift + del : 한 줄 삭제
//- alt + 화살표 : 줄 이동
//- ctrl + 화살표 : 단어 단위 이동
//- ctrl + k, c / ctrl + k, u : 주석 설정 / 해제
//
//[컴파일 / 빌드 / 디버그 개념 메모]
//- 컴파일러(compiler) : 소스코드를 목적코드로 번역
//- 링커(linker) : 목적코드 / 라이브러리 결합 → 실행파일(exe) 생성
//- 빌드(build) : 실행파일 생성, 리빌드(rebuild) : 정리 후 전체 재빌드
//- 디버그(F5) : 중단점(F9)으로 실행 중 상태 / 변수 확인
//- 배포 시.pdb(디버그 심볼) 제외(내부 구조 노출 방지)
//
//[배열(Array)]
//정의 :
//    -같은 자료형(Data Type)의 요소가 "연속적(contiguous)"으로 저장된 구조.
//    장점 :
//    -O(1) 인덱스 접근(임의 접근, random access).
//    단점 :
//    -크기 고정(정적 크기).중간 삽입 / 삭제 비용 큼(밀어내기 / 당기기 필요).
//
//    기본 문법 / 초기화 예시 :
//int a = 10;                            // 스칼라 변수
//int Array[5] = { 0 };                   // 5칸, 모두 0으로 초기화
//Array[0] = 10;                          // 첫 요소
//Array[3] = 40;                          // 네 번째 요소(인덱스 3)
//
//int Array2[5] = { 1,2,3,4,5 };
//int Array3[5] = { 1,2,3 };              // 나머지는 0으로 채움(4,5번째=0)
//int Array4[5] = {};                      // 모두 0 초기화(C++에서만 허용)
//
//const int Size = 5;                      // C++: 컴파일타임 상수 사용
//int Array5[Size] = {};                   // MSVC는 VLA 비허용(C++ 표준에도 없음)
//
//크기 / 요소 수 계산(스코프 내 정적 배열일 때만!) :
//    size_t bytes = sizeof(Array5);           // 전체 바이트
//size_t elem = sizeof(Array5) / sizeof(Array5[0]); // 요소 개수
//
//주의:
//-함수 파라미터로 배열을 넘기면 포인터로 decay되어 sizeof 트릭이 실패함.
//→ 템플릿으로 배열 참조를 받아 크기 추론하는 도우미가 안전.
//template <typename T, size_t N>
//constexpr size_t CountOf(const T(&)[N]) { return N; }
//
//
//[이차원 배열(2D Array)]
//- "행(row)×열(col)" 격자.C / C++은 "행 우선(row-major)" 메모리 배치.
//int M[4][3] = {
//  {1,2,3}, {4,5,6}, {7,8,9}, {0,1,2}
//};
//int x = M[1][2]; // 6
//메모리:
//-int M[4][3] 는 int L[12] 와 같은 연속 메모리(인덱스 변환 : idx = r * 3 + c).
//
//[참조(Reference)]
//정의 :
//    -변수의 "별명(alias)".반드시 선언 시 즉시 어떤 객체에 바인딩, 이후 다른 객체로 재바인딩 불가.
//    - 함수 파라미터에서 값 수정(out) 또는 복사비용 회피에 유용.
//    규칙 / 관례 :
//    -out 파라미터는 관례적으로 접두사 Out / Ref 표기.
//    void ClampInPlace(int& v, int min, int max) {
//    if (v < min) v = min;
//    else if (v > max) v = max;
//}
//const 참조(읽기 전용, 복사 방지) :
//    int SumAll(const std::vector<int>&xs);
//
//[자주 하는 실수 / 교정 리스트]
//- VLA(C++ 비표준) : int n; int a[n];  ✗ → const / constexpr 크기 사용.
//- 평균 계산에서 정수 나눗셈(버림) 주의 →(float) 또는 3.0f 로 나누기.
//- sizeof 트릭은 "함수 파라미터"에서 실패(포인터 decay) → 템플릿 도우미 사용.
//- 셔플 시 srand를 루프마다 호출 ✗ → 프로그램 시작 시 1회만.
//- 2D 배열의 열 수(col)를 곱하지 않고 1D 인덱스 변환 ✗ → idx = r * col + c.
//- 주석 닫기 오탈 : "/* ... /"  ✗ → "/* ... */
//
//[용어사전]
//- contiguous : 메모리가 끊김 없이 이어져 있는 상태.
//- row - major : 행을 기준으로 연속 배치하는 메모리 레이아웃.
//- out - of - bounds): 배열 범위를 벗어난 접근
//- shuffle : 무작위 섞기.
//- reference : 별명 바인딩, 재바인딩 불가.
//
//배열과 포인터는 기본적으로 같다(배열의 이름은 배열의 첫 번째 요소의 주소를 의미한다).
//포인터
//- 메모리 주소를 저장하는 데이터 타입
//각 데이터타입에 * 만 붙이면 포인터 타입
//ex) int* 인티저 포인터, float* 플로트 포인터, char* 캐릭터 포인터
//포인터 연산자
//- 주소 연산자(&)(비트연산자 & 아님)
//int i = 10;
//int* p = &i; //i의 주소를 int*p에 대입해라.
//i가 아파트(이름)라면 거기 주소가 포인터 타입이라고 생각하면 된다.& i가 주소 나옴
//int Number = 1012;
//(&Number) 주소가 된다고 생각해라
//- 간접참조 연산자(*)
//int i = 20;
//int* p = &i;
//(*p) = 30; // i = 30; 과 같다.
//int* p = nullptr;
//int* p2 = nullptr;
//-산술 연산자(+, -, ++, --)
//int i = 30;
//int* p = &i
//p = p + 1; 예시로 p가 0x0004라고 가정했을 때 p + 1값을 한 값은 포인터 주소에 + 1이면
//원래 데이터 파일 크기 증가 시킴 p + 1 = 0x0008
//double d = 10.5;
//double* pD = &d;
//pd += 1; //pd가 원래 0x0000 이라고 가정했을 대  pD += 1은 0x0008
//
//포인터(Pointer)
//- 메모리 주소를 저장하는 데이터 타입
//- 각 데이터 타입에 * 만 붙이면 포인터 타입
//ex) int* 인티저 포인터, float* 플로트 포인터, char* 캐릭터 포인터
//
//포인터 연산자
//- 주소 연산자(&) (비트연산자 & 아님)
//
//int i = 10;
//int* p = &i;   // i의 주소를 int* p에 대입
//i가 아파트(이름)라면, 주소는 집주소, 포인터는 주소를 들고 있는 종이 쪽지 느낌
//& i 하면 주소가 나옴
//
//int Number = 1012;
//(&Number) → Number의 주소
//
//- 간접참조 연산자(*)
//
//int i = 20;
//int* p = &i;
//(*p) = 30;     // i = 30 과 같다.
//*p는 "포인터가 가리키는 메모리의 값"을 의미한다.
//
//int* p = nullptr;   // 포인터를 안전하게 비울 때 nullptr 사용
//int* p2 = nullptr;
//
//-산술 연산자(+, -, ++, --)
//int i = 30;
//int* p = &i;
//p = p + 1;   // 만약 p가 0x0004였다면, int는 4바이트이므로 p+1은 0x0008
//
//double d = 10.5;
//double* pD = &d;
//pD += 1;    // double은 8바이트라서 주소가 8 증가
//
//⚠ 주의
//포인터 산술은 배열 같은 "연속된 공간"에서만 유효하다.
//엉뚱한 주소로 넘어가면 "미정의 동작(프로그램 오류)" 발생.
//
//
//C++ 메모리 영역(단순화)
//
//1. 코드 영역(Code Area)
//→ 실행 코드(기계어) 저장
//
//2. 데이터 영역(Data Area)
//→ 전역 / 정적 변수(프로그램 시작~종료까지 유지)
//
//3. 힙 영역(Heap)
//→ 실행 중 new / malloc으로 할당
//→ OS 요청 → 속도 느림
//→ 반드시 delete / free 해제 필요
//→ 해제 안 하면 "메모리 릭(누수)" 발생
//
//4. 스택 영역(Stack)
//→ 함수 호출 시 지역 변수 저장
//→ 함수 종료 시 자동 정리
//→ 무한 재귀 시 스택 오버플로우 발생
//
//정적 vs 동적
//
//- 정적(static) : 실행 전 크기·생명주기 결정
//ex) 전역 변수, 지역 static 변수, 고정 배열
//
//- 동적(dynamic) : 실행 중 메모리 할당
//ex) new, malloc
//
//
//동적 할당
//
//- 실행 중(Run Time)에 메모리 확보
//- OS에 요청 → 속도 느림
//
//C 스타일
//malloc / free
//- 초기화 없음, 타입 안정성 없음
//- 생성자 / 소멸자 실행 안 됨
//
//C++ 스타일
//new / delete (단일 변수)
//new[] / delete[](배열)
//
//int* Data = new int(5);   // 값 5로 초기화
//delete Data;
//
//int* Array = new int[10]; // int 10개
//delete[] Array;
//
//주의
//- 배열은 반드시 delete[] 사용
//- new int[10];        → 초기화 X(쓰레기값)
//- new int[10]();      → 0으로 초기화
//
//
//메모리 관련 문제
//
//1. 성능 문제
//- 메모리 할당 / 해제 자체가 느림
//
//2. 단편화(Fragmentation)
//- 전체 공간은 충분해도 연속 공간 부족
//
//3. 메모리 릭(Memory Leak)
//- 해제 안 하면 다시 못 씀
//- 규칙: new→delete, new[]→delete[], malloc→free
//
//4. 디버깅
//- Visual Studio : `_CrtDumpMemoryLeaks()` 로 누수 확인
//
//문자열(String) 기본
//- 문자열: 글자 여러 개를 모아 문장을 표현한 것
//- C언어에서는 char* 또는 char[] 로 표현
//- 항상 마지막에 '널 문자(\0)'로 끝남
//- char* 내부에는 문자가 아니라 "아스키 코드 값"이 기록됨
//
//
//
//파싱(Parsing)
//- 문자열을 분석하여 의미 있는 정보로 변환하는 과정
//- 예: "2025-09-10" → 연, 월, 일로 나누어 저장
//
//문자열 관련 예제 코드
//
// 링크 에러 방지용 최소 정의
//void Day0910_String(void)
//{
//    printf("Day0910_String stub\n"); // 추후 내용 채워넣기
//}
//
//문자열 합치기 함수 선언
//void MyStringCat(char* Destination, const char* Source);
//
//문자열 합치기 테스트
//void Day0910_Test3(void)
//{
//    printf("\n\n문자열 합치기");
//
//    char TestSource[32] = "hello";
//    printf("원본 : %s\n", TestSource);
//
//    char ToAppend[] = " world";
//
//     Destination 뒤에 Source 이어붙이기
//    MyStringCat(TestSource, ToAppend);
//
//    printf("합친 결과 : %s\n", TestSource);
//     출력 결과: "hello world"
//}
//
//
//
//std::string(STR) 기본 개념
//
//std::string
//의미 : C++ 표준 라이브러리에서 제공하는 문자열 클래스
//의도 : C언어의 char 배열보다 안전하고 편리하게 문자열을 다루기 위해
//활용 : 복사, 결합, 비교, 검색, 길이 확인 등 문자열 관련 작업 전부
//
//
//문자열 생성
//std::string str1 = "Hello";
//의미: "Hello" 문자열을 복사 초기화
//의도 : 문자열 변수를 간단하게 만드는 방법
//활용 : 기본적인 문자열 저장
//
//std::string str2("World");
//의미: "World" 문자열을 직접 초기화
//의도 : 생성자 직접 호출, 더 명확한 표현
//활용 : 라이브러리 코드나 스타일에 따라 자주 사용
//
//
//문자열 길이
//size_t Length = str1.length();
//의미: 문자열 길이를 size_t 타입으로 반환
//의도 : 문자열의 크기를 확인
//활용 : 반복문, 파싱, 잘라내기 로직
//
//Length = str1.size();
//의미: length와 같은 기능(동일)
//의도 : 다른 컨테이너(vector 등)와 일관성
//활용 : STL 컨테이너와 통일된 사용
//
//
//문자열 결합
//std::string str3 = str1 + " " + str2;
//의미: "Hello" + " " + "World" = "Hello World"
//의도 : 여러 문자열을 합쳐서 하나의 문자열 생성
//활용 : 출력 문장, 로그 메시지 조립
//
//str3 += "!";
//의미: 기존 문자열 끝에 "!" 추가 → "Hello World!"
//의도 : 간단한 문자열 누적
//활용 : 꾸미기, 문장 완성
//
//
//문자열 비교
//if (str1 == str2) {}
//의미: 두 문자열의 내용이 같은지 비교
//활용 : 입력값 확인, 키워드 매칭
//
//if (str1 != str2) {}
//의미: 두 문자열의 내용이 다른지 비교
//활용 : 조건 분기
//
//if (str1 > str2) {}
//의미: 사전식(lexicographical) 순서 비교
//활용 : 정렬, 검색 로직
//
//
//문자열 검색
//size_t pos = str1.find('e');
//의미: 'e' 문자가 나오는 첫 위치를 찾는다.없으면 npos 반환
//의도 : 특정 문자를 찾기 위해
//활용 : 파싱, 치환 시작점 찾기
//
//pos = str1.find('e', pos + 1);
//의미: 이전 위치 이후부터 다시 'e' 찾기
//의도 : 같은 문자의 두 번째, 세 번째 위치 탐색
//활용 : 문자열 탐색 반복
//
//
//문자열 인덱스 접근
//str1[1] = 'E';
//의미: 인덱스 1 위치의 글자를 'E'로 변경
//의도 : 개별 문자 직접 수정
//주의 : 범위 검사 없음, 잘못된 인덱스면 런타임 오류
//
//str1.at(1) = 'E';
//의미: 인덱스 1 위치의 글자를 'E'로 변경(범위 검사 O)
//의도 : 안전하게 접근
//주의 : 범위 벗어나면 예외 발생, 안전성 ↑
//
//
//C 문자열 변환
//str1.c_str();
//의미: std::string 내부를 const char* (C 문자열)로 반환
//의도 : C 함수(printf 등)와 호환
//활용 : printf("%s", str.c_str()) 같이 사용
//주의 : 반환된 포인터는 문자열이 수정되면 무효화됨, 오래 보관 금지