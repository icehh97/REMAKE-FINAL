// 변수 Variable
//"변하는 값"을 담는 이름 있는 메모리 공간
//
//상수 Constant / const
//바뀌지 않는 값.const를 붙이면 수정 불가.
//const int N = 5; // N은 수정 불가(compile-time 상수로 쓰기 좋음)
//
//리터럴 Literal
//코드에 직접 적은 값
//
//기본 자료형
//
//- bool: 논리형, true / false (1바이트)
//- char : 문자 1개(1바이트)
//- int : 정수(보통 4바이트, -2, 147, 483, 648 ~2, 147, 483, 647)
//- long long : 큰 정수(8바이트)
//- float : 단정밀도 실수(4바이트, 소수 약 6~7자리 정확)
//- double : 배정밀도 실수(8바이트, 소수 약 15~16자리 정확)
//- unsigned : 부호 없음(음수X).예) unsigned int
//
//이스케이프 시퀀스
//"\n"(줄바꿈), "\t"(탭), "\\", "\"\"", "\r"(캐리지 리턴; 주로 리눅스 / 터미널)
//
//enum (열거형, enumeration)
//    - 의미 있는 정수 상수의 묶음.가독성↑, 매직넘버 제거.
//    - 예) enum Item { Gun = 1 << 0, Bomb = 1 << 1, ... };
//
//표현식 / 문 Expression / Statement
//- 식(Expression) : 값이 되는 계산식.예) a + b, i < 10
//    - 문(Statement) : 실행 단위.예) a = 3; if (...) { ... }
//
//연산자 Operator
//1) 대입: a = b; // 오른쪽 값을 왼쪽에 복사(오른쪽은 변하지 않음)
//2) 산술: +-*/ %
//-정수 나눗셈 : 7 / 2 == 3 (소수 버림)
//- % : 나머지(modulo) → 5 % 3 == 2
//3) 복합 대입 : a += b;  // a = a + b; ( -=, *=, /=, %= )
//4) 증감: a++; ++a; a--; --a;
//-a++(후위, post) : "사용 후" + 1
//- ++a(전위, pre) : "+1 후" 사용
//- 잘못된 표기 : a++ = (X)
//5) 비교: == , != , <, >,
//
//#define _CRT_SECURE_NO_WARNINGS
//#include <cstdio>    // printf, scanf
//#include <cstdlib>   // srand, rand
//#include <ctime>     // time
//#include <random>    // C++ 난수(random) 엔진/분포
//
//
//- for문(반복문, loop)
//- for (초기식; 조건식; 증감식) { 본문 }
//- 실행 순서 : 초기식 →[조건 검사→본문→증감] 반복 → 조건 거짓이면 종료
//- 예) for (int i = 0; i < 5; ++i) { /* 5회 반복: i=0..4 */ }
//
//비트 연산(bitwise)
//- OR(| ) : 켜기 / 추가, AND(&) : 검사, AND NOT(&~) : 끄기 / 삭제, SHIFT(<< , >> ) : 자리 이동
//- 예) inv |= Gun;    // Gun 추가
//-if (inv & Gun) // Gun 보유 여부 검사
//- inv &= ~Gun;   // Gun 제거
//
//
//[랜덤(Random) 정리:C 스타일 vs C++ 스타일]
//
//1) C 스타일(rand / srand) 요약
//- srand(time(0));           // 실행할 때마다 다른 "시드(seed)" 설정
//-srand(0);                 // 고정 시드(테스트 재현용)
//-int r = rand();           // 0 ~ RAND_MAX 정수
//-int x0_5 = rand() % 6;    // 0~5
//-int x1_6 = rand() % 6 + 1;// 1~6 (주사위)
//
//※ 주의 : (rand() % n)은 "모듈러 편향(modulo bias)"가 있을 수 있음.
//학습·간단 실습은 OK, 정밀 난수는 C++ <random> 권장.
//
//2) C++ 스타일(<random>) 요약  ← 권장(예측 어려움)
//- std::random_device rd;          // 시드 공급원(일부 구현은 의사난수)
//-std::mt19937 gen(rd());         // 메르센 트위스터 엔진(빠르고 품질 좋음)
//-std::uniform_int + _distribution<int> uni(a, b); // [a, b] 균등분포,uniform)
//-int v = uni(gen);               // a~b 정수 1개
//-std::normal_distribution<double> norm(mu, sigma); // 정규분포,(normal/Gaussian)
//-double z = norm(gen);
//
//-1~6:  rand() % 6 + 1
//- 0~n - 1 : rand() % n
//- 정규분포 출력 시 소수점 형식 지정 필요(printf("%.2f", value);)
//
//rand() % 6 + 1 괄호는 현재 우선순위상 필수 아님이 맞으나, 가독성 위해 괄호로 감싸는 습관 추천.
//1e6 반복 정도는 int로 충분.더 큰 카운트는 long long 사용 고려.
//
//
//
//[비교 / 조건 / 논리 기본 요약]
//- 비교연산자(comparison operators) : > , < , >= , <= , == (같다), != (다르다)
//    -결과 타입 : bool → true / false
//    - = (대입, assignment) 와 == (비교, equality)를 절대 혼동하지 말 것!
//
//
//    [if / else if / else]  — 조건(condition)이 true일 때 블록 실행
//    문법 :
//if (조건) { … }
//else if (다른 조건) { … }
//else { … }
//
//주의1) if (cond); ← 세미콜론 실수 금지!(빈 문장을 실행해 버림)
//주의2) 범위 큰 조건 → 작은 조건 순서로 배치하면 가독성↑, 버그↓
//
//
//[switch] — 정수 / 열거형을 값별로 분기.각 case 끝에 break 필수.
//
//
//[삼항 연산자(ternary)]  cond ? A : B
//- cond가 true면 A, false면 B의 값이 선택됨.
//
//[논리 연산자]
//- && (AND), || (OR), !(NOT)
//-단락 평가(short - circuit) : 왼쪽만으로 결과가 확정되면 오른쪽은 평가 안 함.
//
//[개념 보충] 비교 / 논리 / 부정 연산자
//- 같지 않다 : a != b(주의 : 공백 섞은 a != b 는 문법 오류)
//- AND : &&, OR : || , NOT : !
//- 단락 평가(short - circuit) : 왼쪽으로 결과가 결정되면 오른쪽 미평가.
//
//예시(주석) :
//     int a = 10, b = 20;
//     if (a != b) { /* 다름 * / }
//     if ( (a > 5) && (a < 15) ) { /* 범위 내 * / }
//
//
//    [자주 하는 실수 체크리스트]
//- '=' vs '==': 대입과 비교 혼동 금지.
//- if (cond);  ← 세미콜론 실수 금지.
//- float == 비교: epsilon으로 근사 비교.
//- switch : break 빠뜨리지 않기(의도적 fall - through엔 주석 남기기).
//- 변수 스코프 : 사용 직전에 선언(가독성↑).
//- 논리식은 '읽기 쉬운 순서'로 작성(짧은 회로 평가 활용).
//
//
//- 비교(comparison) : 두 값을 대조하여 관계를 판별하는 행위.
//- 조건(condition) : 참 / 거짓을 결정하는 논리식.
//
//[디버그 팁]
//- F9 : 브레이크포인트 설정 / 해제
//- F10 / F11 : 한 줄씩 / 함수 안으로
//- 변수 감시(Watch), 즉시(Immediate) 창으로 식 평가
//- 포맷 출력 : % d(int), % u(unsigned), % f(float), % .2f(소수 둘째 자리), % c(char), % s(C - string)
//
//[디버그 / 포맷 팁]
//- % d(int), % u(unsigned), % f(float), % .2f(소수 둘째), % c(char), % s(C - string)
//- if 뒤에 세미콜론 금지 : if (cond);  ← 버그!
//- 비교 연산자 : == (같다), != (다르다), <, >, <= , >=
//-대입 연산자 : = (절대 혼동 금지)
//
//[용어]
//- modulo : 나머지
//- short - circuit : && /||에서 결과 확정 시 나머지 미평가
//- LSB : 최하위 비트(Least Significant Bit)
//
//
//[제어문(Control Statements) 개요]
//- 프로그램의 흐름을 제어하는 문(statement).
//- 조건문 : if / else if / else, switch, (조건) ? A : B  ← 삼항연산자
//- 반복문 : for / while / do - while
//
//[논리 연산자[Logical)]
//- 피연산자:bool → 결과 : bool
//- && (AND) : 양쪽이 모두 true → true, 그 외 false
//- || (OR) : 둘 중 하나라도 true → true, 둘 다 false → false
//- !(NOT) : 피연산자가 true → false, false → true (참 / 거짓 반전)
//- 단락 평가(short - circuit) : && /||는 왼쪽만으로 결과가 확정되면 오른쪽은 평가하지 않음.
//EN : && and || short - circuit; !negates a boolean.
//주의: 'ture' 오타 주의 → 'true'
//
//[비트 연산자(Bitwise)]  ※ 정수형에 대한 비트 단위 연산
//- &(AND) : 두 비트가 모두 1 → 1, 아니면 0  (플래그 검사에 유용)
//- | (OR) : 두 비트 중 하나라도 1 → 1       (플래그 세팅에 유용)
//- ^ (XOR) : 두 비트가 다르면 1, 같으면 0    (토글 toggle)
//- ~(NOT) : 비트 반전(0↔1)                   (주의 : 2의 보수 표현으로 부호 / 상위비트까지 반전)
//- << (Left) : 왼쪽 시프트(2배씩 커짐처럼 보임)  (오버플로 / 손실 주의, 부호형 금지 권장)
//- >> (Right) : 오른쪽 시프트(2로 나눈 효과처럼 보임)
//* 부호 있는 정수의 >> 는 구현마다 산술 / 논리 시프트 차이 주의(대부분 산술 : 부호비트 유지).
//* 음수 / 너무 큰 시프트 폭은 정의되지 않은 동작(UB).
//
//
//[비트 예시 1:AND로 특정 비트 검사]
//int a = 10; // 0b1010
//int b = 9;  // 0b1001
//int c = (a & b); // 0b1000
//
//[비트 예시 2:OR로 특정 비트 켜기]
//int a2 = 10; // 0b1010
//int b2 = 9;  // 0b1001
//int c2 = (a2 | b2); // 0b1011
//
//[비트 예시 3:XOR로 토글]
//int a3 = 10; // 0b1010
//int b3 = 9;  // 0b1001
//int c3 = (a3 ^ b3); // 0b0011
//
//[비트 예시 4:NOT로 반전(주의)]
//int a4 = 10;     // 0b...00001010 (플랫폼의 int 폭만큼)
//int n4 = ~a4;    // 0b...11110101 (부호/상위비트까지 뒤집힘 → 마스크를 함께 쓰는 습관)
// 예: 하위 4비트만 반전하려면: n4 = (~a4) & 0b1111;
//
//[시프트 예시]
//unsigned int s = 7;   // 0b0111
//s = s << 1;           // 0b1110  (왼쪽으로 1칸: 대략 *2)
//s = s >> 1;           // 0b0111  (오른쪽으로 1칸: 대략 /2)
//
//[플래그(Flag) 패턴 예시] ← 방향키 입력 상태를 4비트로 관리
//- 0b0001 = 왼쪽(Left), 0b0010 = 오른쪽(Right), 0b0100 = 위(Up), 0b1000 = 아래(Down)
//- C++14 이상: 0b 접두 이진 리터럴 사용 가능(MSVC 지원)
//
//int flag = 0b1010; // 현재: Right(0010) + Down(1000)이 켜진 상태
//
// 1) 특정 비트가 켜져 있는지 검사(AND 후 0이 아닌지)
//if ((flag & 0b0010) != 0) {
//     오른쪽 키가 눌려있다.
//}
//else {
//     오른쪽 키가 눌려있지 않다.
//}
//
// 2) 비트를 켜기(OR)
//flag = flag | 0b0001; // Left ON → flag = 0b1011
//
// 3) 비트를 토글(XOR)
//int result = flag ^ 0b0001;   // Left 토글
//result = result ^ 0b0001;     // 다시 토글 → 원복
//
// 4) 비트를 끄기(AND with NOT)
//flag = 0b1010;
//flag = flag & (~0b0010); // Right OFF → 0b1000
//
// 5) 전체 비트 반전 시 하위 N비트만 유지하고 싶을 때는 마스크 사용
//int test = 0b0001;
//int mask4 = 0b1111;
//int inv4 = (~test) & mask4;  // 하위 4비트만 반전 → 0b1110
//
//[enum : 상수 집합에 이름 부여(가독성↑, 매직넘버 제거)]
//- C 스타일 : enum Key { Up = 1 << 0, Down = 1 << 1, Left = 1 << 2, Right = 1 << 3 };
//-사용: if ((flag & Up) != 0) { … }
//주의: enum 항목명 / 변수명 대소문자 일치, 콤마 위치 / 초기화 문법 정확히.
//
//[반복문(Loops)]
//- for : 반복 횟수가 명확할 때(인덱스 기반)
//- while : 조건이 참인 동안(반복 횟수 불명확, 선조건 검사)
//- do - while : 최소 1회 실행 보장(후조건 검사)
//- continue : 이번 반복의 나머지 문장 건너뛰고 다음 반복으로
//- break : 반복문 / switch 탈출
//
//
//[랜덤(Random]
//    - C 스타일 : srand(시드); rand();  // 단순 실습용, 모듈러 편향 가능
//예) srand(time(0)); int dice = rand() % 6 + 1; // 1~6
//-C++ 스타일(<random>) : std::mt19937 엔진 + 분포
//예) std::uniform_int_distribution<int> d(1, 6); int v = d(gen);
//EN: Prefer <random> for quality / reproducibility; avoid modulo bias.
//
//[에디터 / IDE 작업 팁(Visual Studio 기준)]
//- alt + shift + 화살표 : 세로 블록 선택(멀티컬럼)
//- ctrl + d : 한 줄 복제
//- ctrl + space : 자동완성(인텔리센스)
//- shift + del : 한 줄 삭제
//- alt + 화살표 : 줄 이동
//- ctrl + 화살표 : 단어 단위 이동
//- ctrl + k, c / ctrl + k, u : 주석 설정 / 해제
//
//[컴파일 / 빌드 / 디버그 개념 메모]
//- 컴파일러(compiler) : 소스코드를 목적코드로 번역
//- 링커(linker) : 목적코드 / 라이브러리 결합 → 실행파일(exe) 생성
//- 빌드(build) : 실행파일 생성, 리빌드(rebuild) : 정리 후 전체 재빌드
//- 디버그(F5) : 중단점(F9)으로 실행 중 상태 / 변수 확인
//- 배포 시.pdb(디버그 심볼) 제외(내부 구조 노출 방지)
//
//[배열(Array)]
//정의 :
//    -같은 자료형(Data Type)의 요소가 "연속적(contiguous)"으로 저장된 구조.
//    장점 :
//    -O(1) 인덱스 접근(임의 접근, random access).
//    단점 :
//    -크기 고정(정적 크기).중간 삽입 / 삭제 비용 큼(밀어내기 / 당기기 필요).
//
//    기본 문법 / 초기화 예시 :
//int a = 10;                            // 스칼라 변수
//int Array[5] = { 0 };                   // 5칸, 모두 0으로 초기화
//Array[0] = 10;                          // 첫 요소
//Array[3] = 40;                          // 네 번째 요소(인덱스 3)
//
//int Array2[5] = { 1,2,3,4,5 };
//int Array3[5] = { 1,2,3 };              // 나머지는 0으로 채움(4,5번째=0)
//int Array4[5] = {};                      // 모두 0 초기화(C++에서만 허용)
//
//const int Size = 5;                      // C++: 컴파일타임 상수 사용
//int Array5[Size] = {};                   // MSVC는 VLA 비허용(C++ 표준에도 없음)
//
//크기 / 요소 수 계산(스코프 내 정적 배열일 때만!) :
//    size_t bytes = sizeof(Array5);           // 전체 바이트
//size_t elem = sizeof(Array5) / sizeof(Array5[0]); // 요소 개수
//
//주의:
//-함수 파라미터로 배열을 넘기면 포인터로 decay되어 sizeof 트릭이 실패함.
//→ 템플릿으로 배열 참조를 받아 크기 추론하는 도우미가 안전.
//template <typename T, size_t N>
//constexpr size_t CountOf(const T(&)[N]) { return N; }
//
//
//[이차원 배열(2D Array)]
//- "행(row)×열(col)" 격자.C / C++은 "행 우선(row-major)" 메모리 배치.
//int M[4][3] = {
//  {1,2,3}, {4,5,6}, {7,8,9}, {0,1,2}
//};
//int x = M[1][2]; // 6
//메모리:
//-int M[4][3] 는 int L[12] 와 같은 연속 메모리(인덱스 변환 : idx = r * 3 + c).
//
//[참조(Reference)]
//정의 :
//    -변수의 "별명(alias)".반드시 선언 시 즉시 어떤 객체에 바인딩, 이후 다른 객체로 재바인딩 불가.
//    - 함수 파라미터에서 값 수정(out) 또는 복사비용 회피에 유용.
//    규칙 / 관례 :
//    -out 파라미터는 관례적으로 접두사 Out / Ref 표기.
//    void ClampInPlace(int& v, int min, int max) {
//    if (v < min) v = min;
//    else if (v > max) v = max;
//}
//const 참조(읽기 전용, 복사 방지) :
//    int SumAll(const std::vector<int>&xs);
//
//[자주 하는 실수 / 교정 리스트]
//- VLA(C++ 비표준) : int n; int a[n];  ✗ → const / constexpr 크기 사용.
//- 평균 계산에서 정수 나눗셈(버림) 주의 →(float) 또는 3.0f 로 나누기.
//- sizeof 트릭은 "함수 파라미터"에서 실패(포인터 decay) → 템플릿 도우미 사용.
//- 셔플 시 srand를 루프마다 호출 ✗ → 프로그램 시작 시 1회만.
//- 2D 배열의 열 수(col)를 곱하지 않고 1D 인덱스 변환 ✗ → idx = r * col + c.
//- 주석 닫기 오탈 : "/* ... /"  ✗ → "/* ... */
//
//[용어사전]
//- contiguous : 메모리가 끊김 없이 이어져 있는 상태.
//- row - major : 행을 기준으로 연속 배치하는 메모리 레이아웃.
//- out - of - bounds): 배열 범위를 벗어난 접근
//- shuffle : 무작위 섞기.
//- reference : 별명 바인딩, 재바인딩 불가.
//
//배열과 포인터는 기본적으로 같다(배열의 이름은 배열의 첫 번째 요소의 주소를 의미한다).
//포인터
//- 메모리 주소를 저장하는 데이터 타입
//각 데이터타입에 * 만 붙이면 포인터 타입
//ex) int* 인티저 포인터, float* 플로트 포인터, char* 캐릭터 포인터
//포인터 연산자
//- 주소 연산자(&)(비트연산자 & 아님)
//int i = 10;
//int* p = &i; //i의 주소를 int*p에 대입해라.
//i가 아파트(이름)라면 거기 주소가 포인터 타입이라고 생각하면 된다.& i가 주소 나옴
//int Number = 1012;
//(&Number) 주소가 된다고 생각해라
//- 간접참조 연산자(*)
//int i = 20;
//int* p = &i;
//(*p) = 30; // i = 30; 과 같다.
//int* p = nullptr;
//int* p2 = nullptr;
//-산술 연산자(+, -, ++, --)
//int i = 30;
//int* p = &i
//p = p + 1; 예시로 p가 0x0004라고 가정했을 때 p + 1값을 한 값은 포인터 주소에 + 1이면
//원래 데이터 파일 크기 증가 시킴 p + 1 = 0x0008
//double d = 10.5;
//double* pD = &d;
//pd += 1; //pd가 원래 0x0000 이라고 가정했을 대  pD += 1은 0x0008
//
//포인터(Pointer)
//- 메모리 주소를 저장하는 데이터 타입
//- 각 데이터 타입에 * 만 붙이면 포인터 타입
//ex) int* 인티저 포인터, float* 플로트 포인터, char* 캐릭터 포인터
//
//포인터 연산자
//- 주소 연산자(&) (비트연산자 & 아님)
//
//int i = 10;
//int* p = &i;   // i의 주소를 int* p에 대입
//i가 아파트(이름)라면, 주소는 집주소, 포인터는 주소를 들고 있는 종이 쪽지 느낌
//& i 하면 주소가 나옴
//
//int Number = 1012;
//(&Number) → Number의 주소
//
//- 간접참조 연산자(*)
//
//int i = 20;
//int* p = &i;
//(*p) = 30;     // i = 30 과 같다.
//*p는 "포인터가 가리키는 메모리의 값"을 의미한다.
//
//int* p = nullptr;   // 포인터를 안전하게 비울 때 nullptr 사용
//int* p2 = nullptr;
//
//-산술 연산자(+, -, ++, --)
//int i = 30;
//int* p = &i;
//p = p + 1;   // 만약 p가 0x0004였다면, int는 4바이트이므로 p+1은 0x0008
//
//double d = 10.5;
//double* pD = &d;
//pD += 1;    // double은 8바이트라서 주소가 8 증가
//
//⚠ 주의
//포인터 산술은 배열 같은 "연속된 공간"에서만 유효하다.
//엉뚱한 주소로 넘어가면 "미정의 동작(프로그램 오류)" 발생.
//
//
//C++ 메모리 영역(단순화)
//
//1. 코드 영역(Code Area)
//→ 실행 코드(기계어) 저장
//
//2. 데이터 영역(Data Area)
//→ 전역 / 정적 변수(프로그램 시작~종료까지 유지)
//
//3. 힙 영역(Heap)
//→ 실행 중 new / malloc으로 할당
//→ OS 요청 → 속도 느림
//→ 반드시 delete / free 해제 필요
//→ 해제 안 하면 "메모리 릭(누수)" 발생
//
//4. 스택 영역(Stack)
//→ 함수 호출 시 지역 변수 저장
//→ 함수 종료 시 자동 정리
//→ 무한 재귀 시 스택 오버플로우 발생
//
//정적 vs 동적
//
//- 정적(static) : 실행 전 크기·생명주기 결정
//ex) 전역 변수, 지역 static 변수, 고정 배열
//
//- 동적(dynamic) : 실행 중 메모리 할당
//ex) new, malloc
//
//
//동적 할당
//
//- 실행 중(Run Time)에 메모리 확보
//- OS에 요청 → 속도 느림
//
//C 스타일
//malloc / free
//- 초기화 없음, 타입 안정성 없음
//- 생성자 / 소멸자 실행 안 됨
//
//C++ 스타일
//new / delete (단일 변수)
//new[] / delete[](배열)
//
//int* Data = new int(5);   // 값 5로 초기화
//delete Data;
//
//int* Array = new int[10]; // int 10개
//delete[] Array;
//
//주의
//- 배열은 반드시 delete[] 사용
//- new int[10];        → 초기화 X(쓰레기값)
//- new int[10]();      → 0으로 초기화
//
//
//메모리 관련 문제
//
//1. 성능 문제
//- 메모리 할당 / 해제 자체가 느림
//
//2. 단편화(Fragmentation)
//- 전체 공간은 충분해도 연속 공간 부족
//
//3. 메모리 릭(Memory Leak)
//- 해제 안 하면 다시 못 씀
//- 규칙: new→delete, new[]→delete[], malloc→free
//
//4. 디버깅
//- Visual Studio : `_CrtDumpMemoryLeaks()` 로 누수 확인
//
//문자열(String) 기본
//- 문자열: 글자 여러 개를 모아 문장을 표현한 것
//- C언어에서는 char* 또는 char[] 로 표현
//- 항상 마지막에 '널 문자(\0)'로 끝남
//- char* 내부에는 문자가 아니라 "아스키 코드 값"이 기록됨
//
//
//
//파싱(Parsing)
//- 문자열을 분석하여 의미 있는 정보로 변환하는 과정
//- 예: "2025-09-10" → 연, 월, 일로 나누어 저장
//
//문자열 관련 예제 코드
//
// 링크 에러 방지용 최소 정의
//void Day0910_String(void)
//{
//    printf("Day0910_String stub\n"); // 추후 내용 채워넣기
//}
//
//문자열 합치기 함수 선언
//void MyStringCat(char* Destination, const char* Source);
//
//문자열 합치기 테스트
//void Day0910_Test3(void)
//{
//    printf("\n\n문자열 합치기");
//
//    char TestSource[32] = "hello";
//    printf("원본 : %s\n", TestSource);
//
//    char ToAppend[] = " world";
//
//     Destination 뒤에 Source 이어붙이기
//    MyStringCat(TestSource, ToAppend);
//
//    printf("합친 결과 : %s\n", TestSource);
//     출력 결과: "hello world"
//}
//
//
//
//std::string(STR) 기본 개념
//
//std::string
//의미 : C++ 표준 라이브러리에서 제공하는 문자열 클래스
//의도 : C언어의 char 배열보다 안전하고 편리하게 문자열을 다루기 위해
//활용 : 복사, 결합, 비교, 검색, 길이 확인 등 문자열 관련 작업 전부
//
//
//문자열 생성
//std::string str1 = "Hello";
//의미: "Hello" 문자열을 복사 초기화
//의도 : 문자열 변수를 간단하게 만드는 방법
//활용 : 기본적인 문자열 저장
//
//std::string str2("World");
//의미: "World" 문자열을 직접 초기화
//의도 : 생성자 직접 호출, 더 명확한 표현
//활용 : 라이브러리 코드나 스타일에 따라 자주 사용
//
//
//문자열 길이
//size_t Length = str1.length();
//의미: 문자열 길이를 size_t 타입으로 반환
//의도 : 문자열의 크기를 확인
//활용 : 반복문, 파싱, 잘라내기 로직
//
//Length = str1.size();
//의미: length와 같은 기능(동일)
//의도 : 다른 컨테이너(vector 등)와 일관성
//활용 : STL 컨테이너와 통일된 사용
//
//
//문자열 결합
//std::string str3 = str1 + " " + str2;
//의미: "Hello" + " " + "World" = "Hello World"
//의도 : 여러 문자열을 합쳐서 하나의 문자열 생성
//활용 : 출력 문장, 로그 메시지 조립
//
//str3 += "!";
//의미: 기존 문자열 끝에 "!" 추가 → "Hello World!"
//의도 : 간단한 문자열 누적
//활용 : 꾸미기, 문장 완성
//
//
//문자열 비교
//if (str1 == str2) {}
//의미: 두 문자열의 내용이 같은지 비교
//활용 : 입력값 확인, 키워드 매칭
//
//if (str1 != str2) {}
//의미: 두 문자열의 내용이 다른지 비교
//활용 : 조건 분기
//
//if (str1 > str2) {}
//의미: 사전식(lexicographical) 순서 비교
//활용 : 정렬, 검색 로직
//
//
//문자열 검색
//size_t pos = str1.find('e');
//의미: 'e' 문자가 나오는 첫 위치를 찾는다.없으면 npos 반환
//의도 : 특정 문자를 찾기 위해
//활용 : 파싱, 치환 시작점 찾기
//
//pos = str1.find('e', pos + 1);
//의미: 이전 위치 이후부터 다시 'e' 찾기
//의도 : 같은 문자의 두 번째, 세 번째 위치 탐색
//활용 : 문자열 탐색 반복
//
//
//문자열 인덱스 접근
//str1[1] = 'E';
//의미: 인덱스 1 위치의 글자를 'E'로 변경
//의도 : 개별 문자 직접 수정
//주의 : 범위 검사 없음, 잘못된 인덱스면 런타임 오류
//
//str1.at(1) = 'E';
//의미: 인덱스 1 위치의 글자를 'E'로 변경(범위 검사 O)
//의도 : 안전하게 접근
//주의 : 범위 벗어나면 예외 발생, 안전성 ↑
//
//
//C 문자열 변환
//str1.c_str();
//의미: std::string 내부를 const char* (C 문자열)로 반환
//의도 : C 함수(printf 등)와 호환
//활용 : printf("%s", str.c_str()) 같이 사용
//주의 : 반환된 포인터는 문자열이 수정되면 무효화됨, 오래 보관 금지

// HellowWorld.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

// 소스파일
// 주석(Comment) : 프로그램에 영향을 끼치지 않는 부분 (컴파일러가 무시하는 문장)
//

/*
Ctrl+D : 한줄 복제하기
Shift+Delete : 한줄 삭제하기
Shift+화살표 : 블럭 잡기
Alt+Shift+화살표 : 세로로 블럭 잡기
Ctrl+spcae : 자동완성기능(인텔리센스)창 띄우기
Alt+화살표위아래 : 현재 줄을 위아래로 옮기기 ㅠ
프로그램 디버그: <F5 키 또는 [디버그] > [디버깅 시작] 메뉴
Ctrl+B+B : 프로젝트 빌드
Ctrl+B+R : 프로젝트 리빌드
Ctrl+화살표 위아래 : 보이는 영역 올리고 내리기
Ctrl+화살표 좌우 : 단어 단위로 움직이기
Ctrl+K+C : 블럭 영역 전부 주석처리
Ctrl+K+U : 블럭 영역 전부 주석해제 처리
*/

/*
컴파일러 : 번역기(사람이 써 놓은 코드를 기계가 알아듣게 번역해줌)
 -> 목적코드 생성
  -> 링커가 연결해서 실행파일 생성
빌드 : 실행파일 생성하기
리빌드 : 전체 다시 빌드하기(정리+빌드)
*/

/*
변수(Variable)
 - 변하는 숫자
 - 컴퓨터에 값을 기억 시키기 위해 만들고 사용
*/

/*
연산자(Operator)
 - 계산을 하기 위한 기호
 - 대입 연산자
   =
   = 오른쪽에 있는 값을 왼쪽에 넣어라
   a = b; // b에 있는 값을 a에 넣어라
 - 산술 연산자
	사칙연산
	+(더하기) -(빼기) *(곱하기) /(나누기) %(나머지 연산)
	 a = 5%3;
	 a에는 2가 들어간다.( 5를 3으로 나누었을 때 나머지가 2 )
 - 복합 대입연산자
	줄여쓰기용
	a += b;		// 아래와 같은 코드
	a = a + b;
 - 증감 연산자
	a++;	// a에다가 1을 더해라.
	a--;	// a에다가 1을 빼라.
*/

/*
이진수(Binary)
 - 컴퓨터는 0과 1만 알수 있기 때문에 기본적으로 이진수를 사용

 int number = 10;	// 사람이 알아보기 위해 10진수로 값을 대입
					// 실제 메모리에는 0000 0000 0000 0000 0000 0000 0000 1010

 ex) 13 = 2^3 * 1 + 2^2 * 1 + 2^1 * 0 + 2^0 * 1 = 1101
*/

/*
데이터 타입
int : 정수형. 일반적으로 32bit. 범위는 (대략 -21억~+21억)
float : 실수형. 32bit. 태생적으로 오차가 있는 타입. 대략 총7자리부터 오차 발생
double : 실수형. 64bit.
bool : 불리언. true/false만 저장.
char : 캐릭터. 글자하나를 저장하는 데이터 타입. 8bit 정수형
	char alpha = 'a';	// 글자 하나만 저장
	char alpha2 = 64;
std::string : 스트링. 문자열을 쉽게 다룰 수 있는 자료형.
	문자열 : 글자 여러개가 연결된것
	std::string str = "Hello World!";
	char* str;
	char str[32];
*/

/*
상수(Constant)
 - 변하지 않는 수
 - 코드의 안정성과 가독성을 높여준다.
	(매직넘버 회피에 좋다)
	(매크로로와는 달리 타입체크가 가능하다)
*/

/*
비교연산자
 - 비교를 하는 연산자. 참이냐 거짓이냐가 결과로 나온다.
 - >, <, >=, <=, ==

 int a = 10;
 int b = 20;
 bool result = a > b;		// 결과는 거짓이니까 result = false;

 int a = 100;
 int b = 20;
 bool result = a > b;		// 결과는 참이니까 result = true;

 int a = 50;
 int b = 50;
 bool result = a == b;	// 결과는 참이니까 result = true;

 // ‘실수형 자료형은 비교 연산자를 사용하면 안 된다’ 가 맞을까요?
 // 정확하게 이야기하면
	"값이 같은지를 비교하는 ==, <=, >=를 조심해서 사용해야 한다." 입니다.
*/

/*
제어문
 - 프로그램의 흐름을 제어하는 문(Statement)
  - 조건문 : 조건에 따라 프로그램의 흐름을 변경하는 문
	- if, else if, else
	- switch
	- 삼항연산자
  - 반복문 : 일정 조건에 따라 코드를 반복하는 문
*/

/*
논리 연산자
 - bool값을 받아 bool로 된 결과를 낸다.
&&	(And)	&&의 양쪽이 둘 다 true면 true. 그 외는 false
||	(Or)	||의 양쪽에 하나라도 true가 있으면 true, 아니면 false
!	(Not)	! 뒤의 bool이 true면 false, false면 true.
*/

/*
비트 연산자
&	(And)	두 비트가 모두 1이면 1, 아니면 0
	특정 비트가 세팅이 되어 있는지 확인하는데 사용(플래그 검사)
	int a = 10;			// 0b1010
	int b = 9;			// 0b1001
	int c = a & b;		// 0b1000
|	(Or)	두 비트가 하나라도 1이면 1, 둘 다 0이면 0
	특정 비트에 플래그를 세팅하고 싶을 때 사용(플래그 설정)
	int a = 10;			// 0b1010
	int b = 9;			// 0b1001
	int c = a | b;		// 0b1011
^	(XOR)	두 비트가 서로 다르면 1, 같으면 0
	특정 비트를 토글하고 싶을 때 사용
	int a = 10;			// 0b1010
	int b = 9;			// 0b1001
	int c = a ^ b;		// 0b0011
~	(Not)	비트값을 반전 시킨다(0->1, 1->0)
	int a = 10;			// 0b1010
	a = ~a;				// 0b0101
<<	(Left Shift)	비트들을 왼쪽으로 이동
	한번 움직일 때마다 수가 두배가 된다.
	int a = 7;			// 0b0111
	a = a << 1;			// 0b1110
>>	(Right Shift)	비트들을 오른쪽으로 이동
	한번 움직일 때마다 수가 절반이 된다.
	int a = 7;			// 0b0111
	a = a >> 1;			// 0b0011
*/

/*
반복문
 - 제어문 중의 하나
 - 특정 코드 블록을 조건에 따라 여러번 반복해서 실행할 수 있게 해주는 문
 for		반복 회수가 명확할 때 좋음
 while		반복 회수가 명확하지 않고 조건에 따라 반복할 때 사용
 do-while	최소 한번은 무조건 실행해야 할 때 사용.(while과 거의 같음)
*/

/*
* continue
*	- 반복문 안에서 사용
*	- continue를 만나면 그 이후의 코드는 스킵하고 다음 반복을 진행
* break
*	- 반복문이나 switch문에서 반복문을 벗어나거나 case를 종료시킨다.
*/

/*
* 랜덤
*  - 무작위로 숫자를 선택하는 법
*  - C 스타일
*		- rand();			함수 활용
*		- srand(time(0));	시드값 설정
*  - C++ 스타일
*		- #include <random>
*		- c스타일보다 많은 기능을 제공한다.
*/

/*
* 함수(Function)
*  - 특정한 기능을 수행하는 코드블럭
*  - 선언을 하고 사용해야 한다.
*		->함수의 리턴타입, 함수의 이름, 함수의 파라메터를 설정해줘야 한다.
		함수의 리턴타입 : 함수가 끝났을 때 돌려 받을 값의 종류
		함수의 이름 : 함수를 호출(사용)하고 싶을 때 부르는 이름
		함수의 파라메터 : 함수의 입력값. 0개 이상 들어갈 수 있다.
	- 선언을 한 후에는 구현을 정의해야한다.(함수의 실제 동작을 작성)
*/

/*
* 재귀 호출(Recurcive Call)
*  - 함수 안에서 자기자신을 다시 호출하는 함수
*/

/*
* 템플릿(Template) 함수
*  - 데이터 타입에 관계 없이 동일한 로직을 여러 자료형에 대해 사용할 수 있게 해주는 C++의 기능
*  - 컴파일 타임에 실제 사용하는 곳이 있으면 해당 타입으로 코드를 생성한다.
*		-> 해더에 선언과 구현이 함께 있어야 한다.
*/

/*
* 인라인(inline) 함수
*	- 함수 호출문을 해당 함수의 실제 코드로 대체하는 함수
*/

/*
* 스코프
*  - 변수, 함수, 객체등이 유효하게 사용될 수 있는 범위
*  - 일반적으로 선언된 중괄호 안쪽에서만 유효
*  - 지역 변수 : 특정 함수 내에서 선언된 변수
*  - 전역 변수 : 프로그램 전체에서 사용할 수 있는 변수
*/

/*
* 배열(Array)
* - 같은 데이터타입을 가진 요소들이 연속적으로 저장되어 있는 데이터 구조
*   int Array[5];	// int 5개짜리 배열
*   Array[2] = 10;	// 3번째 요소에 접근해서 10을 대입한다.
*
* - 장점 : 빠르게 각 요소에 접근이 가능하다.
* - 단점 : 크기가 고정이다. 중간에 데이터 삽입/삭제가 어렵다.
*
* 이차원 배열
* - 배열을 이차원으로 표현한 것(축이 2개)
* - int Array[4][3] = { {1,2,3}, {4,5,6}, {7,8,9}, {0,1,2}};
*	int 3개짜리 배열이 4줄 들어있다.
*	사실 int Array[12]랑 메모리 구조가 같다.
*/

/*
* 캐스팅(Casting)
*  - 하나의 데이터 타입을 다른 데이터 타입으로 변경하는 행위
*
	int a = 10;
	float b = 15.5f;

	// C 캐스팅
	a = (int)b;	// b를 int형으로 캐스팅해서 a에 대입한다. (C스타일, 명시적 캐스팅)
	a = b;		// b를 a에 대입한다. 그런데 a와 b는 타입이 다르니까 b를 a로 암시적으로 캐스팅해서 대입한다.(C스타일, 암시적 캐스팅)
	b = a;		// 암시적 캐스팅은 대체로 표현이 작은쪽에서 큰쪽으로는 문제없는 경우가 많다.

	// C++ 캐스팅
	// static_cast : C스타일 캐스팅을 안전하게 만든 것. 컴파일 타임에 결정됨
	// dynamic_cast : 다음에(클래스 이후에)
	// const_cast : const 속성을 제거하거나 추가하는데 사용. 사용하지 않는 것이 권장.
	// reinterpret_cast : C스타일 캐스팅에서 위험한 부분. 원래 타입의 구조를 무시하고 새 타입으로 해석하게 한다.
	a = static_cast<int>(b);	// b를 int형으로 캐스팅해서 a에 대입한다. (C++스타일, 명시적 캐스팅)
*/

/*
* 피셔-예이츠 알고리즘
*	- 배열의 내용을 랜덤하게 섞는 셔플 알고리즘
*	- 동일한 확률로 섞이도록 증명 완료된 알고리즘
*
*	- 알고리즘 순서
*		1. 배열의 마지막 요소에서 첫 요소까지 순회.
*		2. 현재 요소의 인덱스(i)와 , 0~i 중 임의의 인덱스(j)를 선택한다.
*		3. i번째 요소와 j번째 요소를 서로 교환
*		4. i가 0이 될 때까지 반복
*/

/*
* 참조(Reference)
*  - 변수의 별명
*		int Number = 10;
*		int& Ref = Number;	// Number의 참조를 Ref라고 결정
*		Ref = 20;			// Number가 20으로 수정된다.
*  - 참조를 변경할 경우 원본 변수도 함께 수정된다. -> 함수 파라메터로 사용하면 편리하다.
*  - 참조는 항상 어떤 변수와 연결되어 있어야 한다.
*  - 함수 파라메터에 참조를 사용할 때
*		- 파라메터 값을 수정하는 출력용 파라메터일 경우 Out이라는 접두사를 붙이는 것이 관례이다.
*		- 파라메터 값을 읽기만 하는 경우에는 const를 붙여줘서 실수로라도 고칠 수 없게 하는 것이 좋다.
*/

/*
* 포인터
* - 메모리 주소를 저장하는 데이터 타입
* - 각 데이터타입에 *만 붙이면 포인터 타입
*	- ex) int* 인티저 포인터, float* 플로트 포인터, char* 캐릭터 포인터
* - 포인터 연산자
*	- 주소 연산자(&) : 변수의 주소를 가져온다.
*		int i = 10;
*		int* p = &i;	// i의 주소를 int* p에 대입해라.
*	- 간접참조 연산자(*) : 포인터 변수가 가리키는 주소에 저장되어 있는 실제 값
*		int i = 20;
*		int* p = &i;
*		(*p) = 30;		// i = 30;과 같다.
*	- 산술 연산자 ( +, -, ++, -- )
*		int i = 30;
*		int* p = &i;
*		p = p + 1;		// 예시로 p가 원래 0x0004라고 가정했을 때 p + 1을 한 값은 4(int의 크기)가 증가해서 0x0008
*		double d = 10.5;
*		double* pD = &d;
*		pD += 1;		// pD가 원래 0x0000이라고 가정했을 때 pD += 1은 8(double의 크기)이 증가해서 0x0008
*  - 배열과 포인터는 기본적으로 같다.(배열의 이름은 배열의 첫번째 요소의 주소이다.)
*/

/*
* C++의 메모리 영역(단순화 된 버전)
*  - 코드 영역 : 실행코드가 저장되는 공간
*  - 데이터 영역
*		프로그램이 시작할 때부터 끝날 때까지 유지되는 변수가 저장되는 공간
*  - 힙 영역
*		램 그 자체
*		프로그램 실행 중에 프로그램이 필요에 따라 직접 메모리를 할당 받고 사용하는 공간
*		힙은 운영체제가 관리하기 때문에 힙을 할당받는 행위는 느리다.
*		메모리를 할당 받았으면 반드시 해제를 해줘야 한다.(해제를 하지 않으면 메모리 릭(메모리 누수) 발생)
*  - 스택 영역
*		함수가 호출될 때마다 필요한 변수(지역 변수)가 저장되는 공간
*		함수가 끝나면 자동으로 정리
*/

/*
* 정적(static)	: 프로그램 실행전에 이미 결정 나 있는 것들.
* 동적(dynamic)	: 프로그램 실행 중에 결정이 되는 것들.
*/

/*
* 동적 할당(Dynamic Allocation)
*  - 프로그램 실행 중(Runtime)에 메모리를 사용하기 위해 확보하는 행위
*  - 운영체제(OS)에게 요청함 -> 그래서 늦다.
*  - C 스타일
*		할당 : malloc
*		해제 : free
*		단순 메모리 블럭만 받는 형식(초기화가 없음. 타입 안정성 없음. 생성자/소멸자 실행안됨)
*  - C++ 스타일
*		할당 : new
*		해제 : 일반 변수는 delete, 배열은 delete[]
*		int* Data = new int(5);		// int 하나를 할당 받는데 주소가 가리키는 값은 5를 설정해라
*		delete Data;
*		Data = nullptr;
*		int* Array = new int[10];	// int 10개짜리 배열을 만들어라
*		delete[] Array;				// 배열은 반드시 이렇게 해제해야 한다.
*		//delete Array; // 절대 이렇게 하면 안된다. 이렇게 하면 Array[0]부분만 할당 해제가 된다.
*		Array = nullptr;
*		특정 객체(Object)를 생성하는 방식.(초기화가 있다. 타입 안정성이 있다. 생성자와 소멸자가 실행된다.)
*  - 메모리 할당과 성능 문제
*		메모리 할당은 오래 걸린다.(컴퓨터 입장에서 느리다. 운영체제의 메모리관리나 적절한 사이즈를 찾는데 시간이 걸림)
*		메모리 단편화 문제(메모리 할당 해제를 반복하다가 전체 빈공간은 충분하지만 연속된 빈공간이 부족해지는 현상)
*  - 메모리 릭(메모리 누수)
*		할당한 메모리를 반환하지 않아 해당 영역을 사용하지 못하게 되는 현상
*/

/*
* 문자열
*  - 글자 여러개를 모아 문장을 만들어 놓은 것.
*  - C언어에서는 문자열을 표현하기 위해 char*를 사용.(=> char[]을 쓰기도 한다)
*  - 항상 마지막 문자열은 널 문자('\0')로 끝난다.
*  - char*에는 아스키 코드가 기록된다.
*/

/*
* 파싱(Parsing)
* - 문자열을 분석해서 의미있는 정보로 변환하는 과정
*/

/*
* 구조체(Struct)
*	- 여러 종류의 데이터타입을 하나로 묶을 때 사용.
*	- 프로그램 코드의 가독성과 유지 보수성을 향상시켜 준다.
*	struct Enemy
*   {
*		std::string Name;
*		float Health;
*		float AttackPower;
*		int DropGold;
*   }
*	Enemy goblin;		// 적 하나에 대한 정보 만들기
*	Enemy goblins[3];	// 적 3마리에 대한 정보 만들기
*
*	- 구조체 동적 할당하는 법
*	Enemy* pGoblin = new Enemy();	// 새 적을 동적할당 받음
*	delete pGoblin;					// 동적할당 받은 것을 해제
*	pGoblin = nullptr;
*
*	- 구조체 데이터 접근법
*		- 일반적인 경우 점(.) 연산자 사용
*			goblin.Name = "고블린";
*			goblin.Health = 20;
*		- 포인터 변수인 경우 화살표(->) 연산자 사용
*			pGoblin->AttackPower = 5.0f;
*			pGoblin->DropGold = 100;
*	- 구조체의 생성자
*		- 객체가 만들어질 때 자동으로 호출되는 특별한 함수
*		- 객체
*			int i = 10;		// 인티저 객체 하나가 만들어짐
*			int array[3];	// 인티저 객체 3개가 만들어짐
*			Enemy* pEnemy = new Enemy();	// Enemy 객체 하나가 만들어짐
*		- 맴버 변수 초기화에 사용(값을 계산하거나 변경해서 넣을 때 좋음)
*		- 일반 함수와 다른 특징
*			1. 이름이 구조체 이름과 같다.
*			2. 리턴 타입이 없다.
*			3. 객체가 만들어질 때 자동으로 호출됨
*			4. 생성자가 여러개 있을 수도 있다.
*			5. 없으면 기본 생성자가 자동으로 만들어진다(무조건 하나는 있다)
*	- 구조체의 명령어 오버로딩(덮어쓰기)
*		- 각종 연산자
*/